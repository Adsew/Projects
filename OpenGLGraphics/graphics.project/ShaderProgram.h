#pragma once

#include <glm/gtc/type_ptr.hpp>

#include "Shader.h"

using ShaderID = unsigned int;

// shader program that holds other shader components
// setup is for later when you can swap shaders in/out of a program
class ShaderProgram : public Object
{
	DECLARE_DYNAMIC_DERIVED_CLASS(ShaderProgram, Object);
private:
	ShaderID m_id;
	using MapUniform = std::map<std::string, int>;
	MapUniform m_uniforms;
	std::list<std::weak_ptr<Shader>> m_shaders;

public:
	ShaderProgram();
	virtual ~ShaderProgram();

	void load(XMLElement* element) override;
	void loadManual(const char *vs, const char *fs);
	void initialize() override;
	// attach another shader
	void attach(std::shared_ptr<Shader> shader);
	// detach another shader
	void detach(Shader* shader);
	// link the shader
	void link();
	// bind the shader program
	void use();
	// unbind the shader as the active program
	void disable();
	ShaderID getID() const;

	// bind uniform that calls the free function binds
	template <typename T>
	void bindUniform(const std::string& name, T data);

	// get the location of a uniform based off shader ID
	int getUniformLocation(const char* name);
};

inline void BindUniform(unsigned int id, const glm::mat4 & mat)
{
	glUniformMatrix4fv(id, 1, GL_FALSE, glm::value_ptr(mat));
}

inline void BindUniform(unsigned int id, const glm::vec3& v)
{
	glUniform3fv(id, 1, &v[0]);
}

inline void BindUniform(unsigned int id, const glm::vec4& v)
{
	glUniform4fv(id, 1, &v[0]);
}

inline void BindUniform(unsigned int id, float data)
{
	glUniform1f(id, data);
}

inline void BindUniform(unsigned int id, bool data)
{
	glUniform1i(id, data);
}

inline void BindUniform(unsigned int id, unsigned int data)
{
	glUniform1ui(id, data);
}

inline void BindUniform(unsigned int id, int data)
{
	glUniform1i(id, data);
}

template<typename T>
inline void ShaderProgram::bindUniform(const std::string & name, T data)
{
	MapUniform::iterator it = m_uniforms.find(name);
	if (it != m_uniforms.end())
	{
		// found the cached value
		BindUniform((*it).second, data);
	}
	else {
		int32_t id = glGetUniformLocation(m_id, name.c_str());
		if (id == GL_INVALID_VALUE)
		{
			std::cout << "shader program id was not generated by OpenGL" << std::endl;
		}
		else if (id == GL_INVALID_OPERATION)
		{
			std::cout << "shader program id is not a GLSL program object OR was not successfully linked" << std::endl;
		}
		else {
			if (id < 0)
			{
				std::cout << name << ": uniform not found!" << std::endl;
			}
			else {
				BindUniform(id, data);
				m_uniforms.insert(std::pair<std::string, int32_t>(name, id));
			}
		}
	}
}
