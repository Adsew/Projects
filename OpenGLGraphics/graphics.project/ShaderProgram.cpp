#include "Core.h"
#include "ShaderProgram.h"
#include "AssetManager.h"


IMPLEMENT_DYNAMIC_CLASS(ShaderProgram);

ShaderProgram::ShaderProgram()
{
	m_id = glCreateProgram();
}

ShaderProgram::~ShaderProgram()
{
	glDeleteProgram(m_id);
}

void ShaderProgram::load(XMLElement * element)
{
	Object::load(element);
	XMLElement* shader = element->FirstChildElement(TO_STRING(Shader));
	while (shader != nullptr)
	{
		if (auto name = shader->Attribute("name"))
		{
			auto asset = AssetManager::instance().getAsset(name);
			if (asset != nullptr && asset->isA(Shader::getClassHashCode()))
			{
				auto shader = std::static_pointer_cast<Shader>(asset);
				if (shader != nullptr)
				{
					attach(shader);
				}
			}
		}

		shader = shader->NextSiblingElement(TO_STRING(Shader));
	}
}

void ShaderProgram::loadManual(const char *vs, const char *fs)
{
    auto asset = AssetManager::instance().getAsset(vs);
    if (asset != nullptr && asset->isA(Shader::getClassHashCode()))
    {
        auto shader = std::static_pointer_cast<Shader>(asset);
        if (shader != nullptr)
        {
            attach(shader);
        }
    }
    asset = AssetManager::instance().getAsset(fs);
    if (asset != nullptr && asset->isA(Shader::getClassHashCode()))
    {
        auto shader = std::static_pointer_cast<Shader>(asset);
        if (shader != nullptr)
        {
            attach(shader);
        }
    }
}

void ShaderProgram::initialize()
{
	Object::initialize();
	link();
}

void ShaderProgram::attach(std::shared_ptr<Shader> shader)
{
	if (shader == nullptr)
	{
		LOG("Found null while attaching shader");
		return;
	}
	auto code = shader->getUUIDHashCode();
	auto it = std::find_if(m_shaders.begin(), m_shaders.end(), [code](auto& s) {
		if (auto shaderPtr = s.lock())
		{
			return shaderPtr->getUUIDHashCode() == code;
		}
		return false;
	});
	if (it == m_shaders.end() && shader->isCompiled())
	{
		LOG("Attaching shader...");
		glAttachShader(m_id, shader->getID());
		m_shaders.push_back(shader);
	}
}

void ShaderProgram::detach(Shader* shader)
{
	if (shader == nullptr)
	{
		LOG("Found null while detaching shader");
	}
	auto code = shader->getUUIDHashCode();
	m_shaders.remove_if([code](auto& ss)
	{
		if (auto shaderPtr = ss.lock())
		{
			return shaderPtr->getUUIDHashCode() == code;
		}
		return false;
	});
	glDetachShader(m_id, shader->getID());
}

void ShaderProgram::link()
{
	glLinkProgram(m_id);

	int32_t status;
	glGetProgramiv(m_id, GL_LINK_STATUS, &status);
	if (!status)
	{
		std::cout << "shader program failed to link" << std::endl;
	}
	else {
		// clear the cached uniforms used before
		m_uniforms.clear();
		std::cout << "shader program successfully linked" << std::endl;
	}
}

void ShaderProgram::use()
{
	glUseProgram(m_id);
}

void ShaderProgram::disable()
{
	glUseProgram(0);
}

ShaderID ShaderProgram::getID() const
{
	return m_id;
}

int ShaderProgram::getUniformLocation(const char * name)
{
	MapUniform::iterator it = m_uniforms.find(name);
	if (it != m_uniforms.end())
	{
		return (*it).second;
	}
	else {
		int32_t id = glGetUniformLocation(m_id, name);
		if (id == GL_INVALID_VALUE)
		{
			std::cout << "shader program id was not generated by OpenGL" << std::endl;
		}
		else if (id == GL_INVALID_OPERATION)
		{
			std::cout << "shader program id is not a GLSL program object OR was not successfully linked" << std::endl;
		}
		else {
			if (!id)
			{
				std::cout << "uniform not found!" << std::endl;
			}
			else {
				m_uniforms.insert(std::pair<std::string, int32_t>(name, id));
			}
			return id;
		}
	}
	return -1; // failed to find uniform location
}